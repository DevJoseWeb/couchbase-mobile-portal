<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>Document | Couchbase Mobile - Developers</title><link rel="stylesheet" type="text/css" href="../../../../../styles/style.css"></link><style class="language-stripe" id="language-stripe-objective-c" type="text/css">*.stripe-display.objective-c{display:inline;}*.stripe-active.objective-c{background:rgba(0, 0, 0, 0.05);}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-swift" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:inline;}*.stripe-active.swift{background:rgba(0, 0, 0, 0.05);}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-java" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:inline;}*.stripe-active.java{background:rgba(0, 0, 0, 0.05);}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-android" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:inline;}*.stripe-active.android{background:rgba(0, 0, 0, 0.05);}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-c" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:inline;}*.stripe-active.c{background:rgba(0, 0, 0, 0.05);}</style><script type="text/javascript">var languages = ["objective-c","swift","java","android","c"];
                    
	                var cookies = document.cookie.split(';');
				    for(var i=0; i<cookies.length; i++) {
				        var cookie = cookies[i].trim();
				        
				        if (cookie.indexOf("language=")==0) {
				            var selectedLanguage = cookie.substring(9, cookie.length);
				            if (selectedLanguage.length > 0) {
				                document.write("<style class='language-stripe' type='text/css'>");
				                for (var j=0; j<languages.length; j++) {
				                    var language = languages[j];
				                    document.write("*.stripe-display." + language + "{display:" + (language == selectedLanguage ? "inline" : "none") + ";}");
                                    document.write("*.stripe-active." + language + "{background:" + (language == selectedLanguage ? "rgba(0, 0, 0, 0.05)" : "transparent") + ";}");
				                }
				                document.write("</style>");
				            }
				            break;
				        }
				    }
				    
			    </script><script type="text/javascript">
                var rootPath = "../../../../../";</script><script src="../../../../../scripts/core.js"></script><script src="../../../../../scripts/search-core.js"></script><script src="../../../../../scripts/search.js"></script><script src="../../../../../scripts/search-index.js"></script><noscript>
            <iframe src="//www.googletagmanager.com/ns.html?id=GTM-MVPNN2" height="0" width="0" style="display:none;visibility:hidden"></iframe>
        </noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-MVPNN2');
        </script><script type="text/javascript">
            document.write(unescape("%3Cscript src='//munchkin.marketo.net/munchkin.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script>Munchkin.init('302-GJY-034');</script></head><body onload="init()"><div class="page-header"><table class="navigator-bar"><tr><td><a class="dark logo" href="../../../../../index.html"><div>Couchbase Mobile</div><div>Developers</div></a></td><td><a class="dark" href="../../../../../get-started/couchbase-mobile-overview/index.html">Get Started</a></td><td><a class="dark active" href="../../../../../develop/training/build-first-ios-app/index.html">Develop</a></td><td><a class="dark" href="https://forums.couchbase.com/mobile">Forums</a></td><td width="100%"></td><td><input class="search" type="text" onkeyup="search_onkeyup(this)" onchange="search_onchange(this)" onfocus="search_onfocus(this)" onblur="search_onblur(this)"></input></td></tr></table><div class="search-results-wrapper"><div class="search-results-floater"><div id="search-results" class="hidden"></div></div></div><div class="secondary-navigator-bar"><table class="items"><tr><td><a class="dark" href="../../../../../develop/training/build-first-ios-app/index.html">Training</a></td><td><a class="dark active" href="../../../../../develop/guides/modeling/index.html">Guides</a></td><td><a class="dark" href="../../../../../develop/references/couchbase-lite/index.html">API References</a></td><td><a class="dark" href="../../../../../develop/samples/samples/index.html">Samples</a></td><td><a class="dark" href="http://www.couchbase.com/nosql-databases/downloads#Couchbase_Mobile">Downloads</a></td><td width="100%"></td></tr></table></div></div><div class="header-spacer"></div><div class="page-wrapper"><nav><ul class="nav-list"><li class="nav-section"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/modeling/index.html">Data Modeling</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/modeling/basics/index.html">The Basics</a></li><li class="nav-item"><a href="../../../../../develop/guides/modeling/one-to-many/index.html">One-to-Many Relationships</a></li></ul></li><li class="nav-section expanded"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/couchbase-lite/index.html">Couchbase Lite</a></div><ul><li class="nav-subsection expanded"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/couchbase-lite/native-api/index.html">Native API</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/manager/index.html">Manager</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/database/index.html">Database</a></li><li class="nav-item active"><a href="../../../../../develop/guides/couchbase-lite/native-api/document/index.html">Document</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">Revision</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/attachment/index.html">Attachment</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/view/index.html">View</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/query/index.html">Query</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/replication/index.html">Replication</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/model/index.html">Model (iOS only)</a></li></ul></li></ul></li><li class="nav-section"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/index.html">Sync Gateway</a></div><ul><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/index.html">Running the Sync Gateway</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/installing-sync-gateway/index.html">Installing Sync Gateway</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/connecting-sync-gateway-to-couchbase-server/index.html">Connecting Sync Gateway to Couchbase Server</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/starting-sync-gateway/index.html">Starting Sync Gateway</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/stopping-sync-gateway/index.html">Stopping Sync Gateway</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/index.html">Configuration and administration</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/command-line-tool/index.html">Configuration options</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/administering-the-rest-apis/index.html">Administering the REST APIs</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/authorizing-users/index.html">Authorizing Users</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/authenticating-users/index.html">Authenticating Users</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/channels/index.html">Data routing with "channels"</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/intro/index.html">Introduction to channels</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/developing/index.html">Developing channels</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/troubleshooting/index.html">Troubleshooting channels</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/index.html">Sync Function API</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/intro/index.html">Introduction</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/validation/index.html">Validation and Authorization</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/routing/index.html">Routing</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/changes-worker/index.html">Connecting additional backend processes</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/pattern/index.html">Changes Worker Pattern</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/example-workflow/index.html">Example Document Workflow</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/push/index.html">Push Notification Code</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/deployment/index.html">Deployment considerations</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/during-development/index.html">During Development</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/in-production/index.html">In Production</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/troubleshooting/index.html">Troubleshooting and Fine-Tuning</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/nginx/index.html">Deploying Sync Gateway behind a reverse proxy</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/nginx/introduction-to-reverse-proxies/index.html">Introduction to reverse proxies</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/nginx/configuring-nginx-for-sync-gateway/index.html">Deploying and configuring nginx</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/accessing-cb-views/index.html">Accessing Couchbase Server views via Sync Gateway</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/accessing-cb-views/creating-and-using-a-view/index.html">Creating and querying a View</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/os-level-tuning/index.html">OS Level Tuning</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/os-level-tuning/max-file-descriptors/index.html">Tuning the max no. of file descriptors</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/os-level-tuning/tcp-keep-alive/index.html">Tuning the TCP Keepalive parameters</a></li></ul></li></ul></li></ul></nav><article class="content-wrapper"><h1>Document</h1><div class="toc"><h2>In this document</h2><ul class="plain"><li><a href="#crud">Creating, Reading, Updating and Deleting documents (CRUD)</a><ul><li><a href="#creating">Creating documents</a></li><li><a href="#reading">Reading documents</a></li><li><a href="#updating">Updating documents</a></li><li><a href="#deleting">Deleting documents</a></li></ul></li><li><a href="#notifications">Document change notifications</a></li><li><a href="#Understanding Conflicts">Conflicts</a><ul><li><a href="#conflict-faq">Document Conflict FAQ</a></li></ul></li><li><a href="#purging-a-document">Purging documents</a></li><li><a href="#special-properies">Special Properties</a></li></ul></div><p>In a <em>document database</em> such as Couchbase Lite, the primary entity stored in a database is called a <strong>document</strong> instead of a "row" or "record". This reflects the fact that a document can store more data, with more structure, than its equivalent in other databases.</p><p>In Couchbase Lite (as in Couchbase Server and CouchDB) a document's <strong>body</strong> takes the form of a JSON object — a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects. Every document is identified by a <strong>document ID</strong>, which can be automatically generated (as a UUID) or determined by the application; the only constraints are that it must be unique within the database, and it can't be changed.</p><p>In addition, a document can contain <strong><a href="../../../../../develop/guides/couchbase-lite/native-api/attachment/index.html">attachments</a></strong>, named binary blobs that are useful for storing large media files or other non-textual data. Couchbase Lite supports attachments of unlimited size, although the Sync Gateway currently imposes a 10MB limit for attachments synced to it.</p><p>Couchbase Lite keeps track of the change history of every document, as a series of <strong><a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">revisions</a></strong>. This is somewhat like a version control system such as Git or Subversion, although its main purpose is not to be able to access old data, but rather to assist the replicator in deciding what data to sync and what documents have conflicts. Every time a document is created or updated, it is assigned a new unique <strong>revision ID</strong>. The IDs of past revisions are available, and the contents of past revisions <em>may</em> be available, but only if the revision was created locally and the database has not yet been compacted.</p><p>To summarize, a document has the following attributes:</p><ul><li>A document ID</li><li>A current revision ID (which changes every time the document is updated)</li><li>A history of past revision IDs (usually linear, but will form a branching tree if the document has or has had conflicts)</li><li>A body in the form of a JSON object, i.e. a set of key/value pairs</li><li>Zero or more named binary attachments</li></ul><h2 id="crud">Creating, Reading, Updating and Deleting documents (CRUD)</h2><hr></hr>
                <p>Couchbase Lite of course supports the typical database "CRUD" operations on documents: Create, Read, Update, Delete.</p>
                
                
                <h3 id="creating">Creating documents</h3><p>You can create a document with or without giving it an ID. If you don't need or want to define your own ID, call the <a href="../../../../../develop/guides/couchbase-lite/native-api/database/index.html">Database</a> method <code>createDocument</code>, and the ID will be generated randomly in the form of a Universally Unique ID (UUID), which looks like a string of hex digits. The uniqueness ensures that there is no chance of an accidental collision by two client apps independently creating different documents with the same ID, then replicating to the same server.</p><p>The following example shows how to create a document with an automatically-assigned UUID:</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>NSString* owner = [@"profile:" stringByAppendingString: userId];
NSDictionary* properties = @{@"type":       @"list",
                             @"title":      title,
                             @"created_at": currentTimeString,
                             @"owner":      owner,
                             @"members":    @[]};
CBLDocument* document = [database createDocument];
NSError* error;
if (![document putProperties: properties error: &amp;error]) {
    [self handleError: error];
}
</code></pre></span><span class="stripe-display swift"><pre><code>let owner = "profile".stringByAppendingString(userId)
let properties = [
    "type": "list",
    "title": title,
    "owner": owner,
    "memebers": []
]
let document = database.createDocument()
var error: NSError?
if document.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("type", "list");
properties.put("title", title);
properties.put("created_at", currentTimeString);
properties.put("owner", "profile:" + userId);
properties.put("members", new
ArrayList&lt;String&gt;());
Document document = database.createDocument();
document.putProperties(properties); 
    
</code></pre></span><span class="stripe-display android"><pre><code>Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("type", "list");
properties.put("title", title);
properties.put("created_at", currentTimeString);
properties.put("owner", "profile:" + userId);
properties.put("members", new
ArrayList&lt;String&gt;());
Document document = database.createDocument();
document.putProperties(properties); 
    
</code></pre></span><span class="stripe-display c"><pre><code>var document = database.CreateDocument();
var properties = new Dictionary&lt;string, object&gt;()
    {
        {"type", "list"},
        {"title", "title"},
        {"created_at", DateTime.UtcNow.ToString ("o")},
        {"owner", "profile:" + userId},
        {"members", new List&lt;string&gt;()}
    };
var rev = document.PutProperties(properties);
Debug.Assert(rev != null);
</code></pre></span><p>If you do want to choose the document's ID, just call the Database method <code>getDocument</code>, just as you would to retrieve an existing document. If the document doesn't exist yet, you still get a valid Document object, it just doesn't have any revisions or contents yet. The first time you save the document, it will be added persistently to the database. If a document does already exist with the same ID, saving the document will produce a conflict error.</p><p>The following example shows how to create a document with an custom ID:</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>NSDictionary* properties = @{@"title":      @"Little, Big",
                             @"author":     @"John Crowley",
                             @"published":  1982};
CBLDocument* document = [database documentWithID: @"978-0061120053"];
NSError* error;
if (![document putProperties: properties error: &amp;error]) {
    [self handleError: error];
}
    
</code></pre></span><span class="stripe-display swift"><pre><code>let properties =
[
    "title": "Little, Big",
    "author": "John Crowley",
    "published":  1982
]
let document = database.documentWithID("978-0061120053")
var error: NSError?
if document.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("title", "Little, Big");
properties.put("author", "John Crowley");
properties.put("published", 1982);
Document document = database.getDocument("978-0061120053");
try {
    document.putProperties(properties);
} catch (CouchbaseLiteException e) {
    Log.e(TAG, "Cannot save document", e);
}
</code></pre></span><span class="stripe-display android"><pre><code>Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.put("title", "Little, Big");
properties.put("author", "John Crowley");
properties.put("published", 1982);
Document document = database.getDocument("978-0061120053");
try {
    document.putProperties(properties);
} catch (CouchbaseLiteException e) {
    Log.e(TAG, "Cannot save document", e);
}
</code></pre></span><span class="stripe-display c"><pre><code>var properties = new Dictionary&lt;string, object&gt;
    {
        {"title", "Little, Big"},
        {"author", "John Crowley"},
        {"published", 1982}
    };
var document = database.GetDocument("978-0061120053");
Debug.Assert(document != null);
var rev = document.PutProperties(properties);
Debug.Assert(rev != null);
</code></pre></span><div class="note tip"><span class="tag">Tip:</span>It's up to you whether to assign your own IDs or use random UUIDs. If the documents are representing entities that already have unique IDs — like email addresses or employee numbers — then it makes sense to use those, especially if you need to ensure that there can't be two documents representing the same entity. For example, in a library cataloging app, you wouldn't want two librarians to independently create duplicate records for the same book, so you might use the book's ISBN as the document ID to enforce uniqueness.</div>
                
                
                <h3 id="reading">Reading documents</h3><p>To retrieve a Document object given its ID, call the Database method <code>getDocument</code>. As described in the previous section, if there is no document with this ID, this method will return a valid but empty Document object. (If you would rather get a null/nil result for a nonexistent document, call <code>existingDocumentWithID</code> instead.)</p><p>Document objects, like document IDs, are unique. That means that there is never more than one Document object in memory that represents the same document. If you call <code>getDocument</code> multiple times with the same ID, you get the same Document object every time. This helps conserve memory, and it also makes it easy to compare Document object references (pointers) — you can just use <code>==</code> to check whether two references refer to the same document.</p><p>Loading a Document object doesn't immediately read its properties from the database. Those are loaded on demand, when you call an accessor method like <code>getProperties</code> (or access the Objective-C property <code>properties</code>). The properties are represented using whatever platform type is appropriate for a JSON object. In Objective-C they're an <code>NSDictionary</code>, in Java a <code>Map&lt;String,Object&gt;</code>.</p><p>Here's a simple example of getting a document's properties:</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
// We can directly access properties from the document object:
NSString* title = doc[@"title"];
// Or go through its properties dictionary:
NSDictionary* properties = doc.properties;
NSString* owner = properties[@"owner"];
</code></pre></span><span class="stripe-display swift"><pre><code>let doc = database.documentWithID(myDocID)
// We can directly access properties from the document object:
let title = doc["title"] as? String
// Or go through its properties dictionary:
let properties = doc.properties;
let owner = properties["owner"] as? String;
</code></pre></span><span class="stripe-display java"><pre><code>Document doc = database.getDocument(myDocId);
// We can directly access properties from the document object:
doc.getProperty("title");
// Or go through its properties dictionary:
Map&lt;String, Object&gt; properties = doc.getProperties();
String owner = (String) properties.get("owner");
</code></pre></span><span class="stripe-display android"><pre><code>Document doc = database.getDocument(myDocId);
// We can directly access properties from the document object:
doc.getProperty("title");
// Or go through its properties dictionary:
Map&lt;String, Object&gt; properties = doc.getProperties();
String owner = (String) properties.get("owner");
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
// We can directly access properties from the document object:
doc.GetProperty("title");
// Or go through its properties dictionary:
var owner = doc.Properties["owner"];
</code></pre></span><div class="note"><span class="tag">Note:</span>The <code>getProperties</code> method is actually just a convenient shortcut for getting the Document's <code>currentRevision</code> and then getting <em>its</em> <code>properties</code> — since a document usually has multiple <a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">revisions</a>, the properties really belong to a revision. Every existing document has a current revision (in fact that's how you can tell whether a document exists or not.) Almost all the time you'll be accessing a document's current revision, which is why the convenient direct properties accessor exists.</div>
                
                
                <h3 id="updating">Updating documents</h3><p>There are two methods that update a document: <code>putProperties</code> and <code>update</code>. We'll cover them both, then explain why they're different.</p><p><code>putProperties</code> is simpler: given a new JSON object, it replaces the document's body with that object. Actually what it does is creates a new <a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">revision</a> with those properties and makes it the document's current revision.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
NSMutableDictionary* p = [doc.properties mutableCopy];
p[@"title"] = title;
p[@"notes"] = notes;
NSError* error;
if (![doc putProperties: p error: &amp;error]) {
    [self handleError: error];
}
</code></pre></span><span class="stripe-display swift"><pre><code>let doc = database.documentWithID(myDocID)
var properties = doc.properties
properties["title"] = title
properties["notes"] = notes
var error: NSError?
if doc.putProperties(properties, error: &amp;error) == nil {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Document doc = database.getDocument(myDocID);
Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.putAll(doc.getProperties());
properties.put("title", title);
properties.put("notes", notes);
try {
    doc.putProperties(properties);
} catch (CouchbaseLiteException e) {
    e.printStackTrace();
}
</code></pre></span><span class="stripe-display android"><pre><code>Document doc = database.getDocument(myDocID);
Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
properties.putAll(doc.getProperties());
properties.put("title", title);
properties.put("notes", notes);
try {
    doc.putProperties(properties);
} catch (CouchbaseLiteException e) {
    e.printStackTrace();
}
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
var p = new Dictionary&lt;string, object&gt;(doc.Properties)
    {
        {"title", title},
        {"notes", notes}
    };
var rev = doc.PutProperties(p);
Debug.Assert(rev != null);
</code></pre></span><div class="note"><span class="tag">Note:</span>Multiple updates using <code>putProperties</code> within a single transaction are currently not supported. For more information, see <a href="https://github.com/couchbase/couchbase-lite-ios/issues/256">issue #256</a> and <a href="https://github.com/couchbase/couchbase-lite-android/issues/220">issue #220</a>.</div><p><code>update</code> instead takes a callback function or block (the details vary by language). It loads the current revision's properties, then calls this function, passing it an <code>UnsavedRevision</code> object, whose properties are a <em>mutable</em> copy of the current ones. Your callback code can modify this object's properties as it sees fit; after it returns, the modified revision is saved and becomes the current one.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
NSError* error;
if (![doc update: ^BOOL(CBLUnsavedRevision *newRev) {
    newRev[@"title"] = title;
    newRev[@"notes"] = notes;
    return YES;
} error: &amp;error]) {
    [self handleError: error];
}
</code></pre></span><span class="stripe-display swift"><pre><code>let doc = database.documentWithID(myDocID)
var error: NSError?
doc.update({ (newRev) -&gt; Bool in
    newRev["titie"] = title
    newRev["notes"] = notes
    return true
}, error: &amp;error)
if error != nil {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        Map&lt;String, Object&gt; properties = newRevision.getUserProperties();
        properties.put("title", title);
        properties.put("notes", notes);
        newRevision.setUserProperties(properties);
        return true;
    }
});
</code></pre></span><span class="stripe-display android"><pre><code>Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        Map&lt;String, Object&gt; properties = newRevision.getUserProperties();
        properties.put("title", title);
        properties.put("notes", notes);
        newRevision.setUserProperties(properties);
        return true;
    }
});
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
doc.Update((UnsavedRevision newRevision) =&gt; 
{
    var properties = newRevision.Properties;
    properties["title"] = title;
    properties["notes"] = notes;
    return true;
});
</code></pre></span><p>Whichever way you save changes, you need to consider the possibility of <strong>update conflicts</strong>. Couchbase Lite uses Multiversion Concurrency Control (MVCC) to guard against simultaneous changes to a document. (Even if your app code is single-threaded, the replicator runs on a background thread and can be pulling <a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">revisions</a> into the database at the same time you're making changes.) Here's the typical sequence of events that creates an update conflict:</p><ol><li>Your code reads the document's current properties, and constructs a modified copy to save</li><li>Another thread (perhaps the replicator) updates the document, creating a new revision with different properties</li><li>Your code updates the document with its modified properties</li></ol><p>Clearly, if your update were allowed to proceed, the change from step 2 would be overwritten and lost. Instead, the update will fail with a conflict error. Here's where the two API calls differ:</p><ol><li><code>putProperties</code> simply returns the error to you to handle. You'll need to detect this type of error, and probably handle it by re-reading the new properties and making the change to those, then trying again.</li><li><code>update</code> is smarter: it handles the conflict error itself by re-reading the document, then <em>calling your block again</em> with the updated properties, and retrying the save. It will keep retrying until there is no conflict.</li></ol><div class="note tip"><span class="tag">Tip:</span>Of the two techniques, calling <code>update</code> may be a bit harder to understand initially, but it actually makes your code simpler and more reliable. We recommend it. (Just be aware that your callback block can be called multiple times.)</div>
                
                
                <h3 id="deleting">Deleting documents</h3><p>The <code>delete</code> method (<code>deleteDocument:</code> in Objective-C) deletes a document:</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
NSError* error;
if (![doc deleteDocument: &amp;error]) {
    [self handleError: error];
}
</code></pre></span><span class="stripe-display swift"><pre><code>let doc = database.documentWithID(myDocID)
var error: NSError?
if !doc.deleteDocument(&amp;error) {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Document task = (Document) database.getDocument("task1");
task.delete(); 
</code></pre></span><span class="stripe-display android"><pre><code>Document task = (Document) database.getDocument("task1");
task.delete(); 
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
doc.Delete();
</code></pre></span><p>Deleting a document actually just creates a new <a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">revision</a>
                        (informally called a "tombstone") that has the special
                        <code>_deleted</code> property set to <code>true</code>. This ensures that
                        the deletion will replicate to the server, and then to other endpoints that
                        pull from that database, just like any other document revision.</p><div class="note"><span class="tag">Note:</span>It's possible for the <code>delete</code> call to fail with a conflict error, since it's really just a special type of <code>putProperties</code>. In other words, something else may have updated the document at the same time you were trying to delete it. It's up to your app whether it's appropriate to retry the delete operation.</div><p>If you need to preserve one or more fields in a document that
                        you want to delete (like a record of who deleted it or when it was deleted)
                        you can avoid the <code>delete</code> method; just update the document and
                        set the <code>UnsavedRevision</code>'s <code>deletion</code> property to
                        <code>true</code>, or set JSON properties that include a
                        <code>"_deleted"</code> property with a value of <code>true</code>. You
                        can retain all of the fields, as shown in the following example, or you can
                        remove specified fields so that the tombstone revision contains only the
                        fields that you need.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
NSError* error;
if (![doc update: ^BOOL(CBLUnsavedRevision *newRev) {
    newRev.isDeletion = YES;  // marks this as a 'tombstone'
    newRev[@"deleted_at"] = currentTimeString;
} error: &amp;error]) {
    [self handleError: error];
}
</code></pre></span><span class="stripe-display swift"><pre><code>doc.update({ (newRev) -&gt; Bool in
    newRev.isDeletion = true
    newRev["deleted_at"] = currentTimeString
    return true
}, error: &amp;error)
if error != nil {
    self.handleError(error)
}
</code></pre></span><span class="stripe-display java"><pre><code>Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        newRevision.setIsDeletion(true);
        Map&lt;String, Object&gt; properties = newRevision.getUserProperties();
        properties.put("deleted_at", currentTimeString);
        newRevision.setUserProperties(properties);
        return true;
    }
})
</code></pre></span><span class="stripe-display android"><pre><code>Document doc = database.getDocument(myDocId);
doc.update(new Document.DocumentUpdater() {
    @Override
    public boolean update(UnsavedRevision newRevision) {
        newRevision.setIsDeletion(true);
        Map&lt;String, Object&gt; properties = newRevision.getUserProperties();
        properties.put("deleted_at", currentTimeString);
        newRevision.setUserProperties(properties);
        return true;
    }
})
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
doc.Update((UnsavedRevision newRevision) =&gt; 
{
    newRevision.IsDeletion = true;
    newRevision.Properties["deleted_at"] = currentTimeString;
    return true;
});
</code></pre></span>
            <h2 id="notifications">Document change notifications</h2><hr></hr>
                <p>You can register for notifications when a particular document is updated or deleted. This is very useful if you're display a user interface element whose content is based on the document: use the notification to trigger a redisplay of the view.</p>
                <p>You can use change events for the following purposes:</p>
                <ul><li>To be notified when new revisions are added to a
								document</li><li>To be notified when a document is deleted</li><li>To be notified when a document enters into a conflicted
								state</li></ul>
                <div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>[[NSNotificationCenter defaultCenter] addObserverForName: kCBLDocumentChangeNotification
            object: myDocument
             queue: nil
        usingBlock: ^(NSNotification *n) {
            CBLDatabaseChange* change = n.userInfo[@"change"];
            NSLog(@"There is a new revision, %@", change.revisionID);
            [self setNeedsDisplay: YES];  // redraw the view
        }
];
</code></pre></span><span class="stripe-display swift"><pre><code>NSNotificationCenter.defaultCenter().addObserverForName(kCBLDocumentChangeNotification, object: myDocument, queue: nil) { 
    (notification) -&gt; Void in
        if let change = notification.userInfo!["change"] as? CBLDatabaseChange {
            NSLog("This is a new revision, %@", change.revisionID);
            set.setNeedsDisplay(true)
        }
}
</code></pre></span><span class="stripe-display java"><pre><code>Document doc = database.createDocument();
doc.addChangeListener(new Document.ChangeListener() { 
    @Override 
    public void changed(Document.ChangeEvent event) { 
        DocumentChange docChange = event.getChange();
        String msg = "New revision added: %s. Conflict: %s"; 
        msg = String.format(msg,
        docChange.getAddedRevision(), docChange.isConflict()); 
        Log.d(TAG, msg);
        documentChanged.countDown();
    } 
}); 
doc.createRevision().save();
</code></pre></span><span class="stripe-display android"><pre><code>Document doc = database.createDocument();
doc.addChangeListener(new Document.ChangeListener() { 
    @Override 
    public void changed(Document.ChangeEvent event) { 
        DocumentChange docChange = event.getChange();
        String msg = "New revision added: %s. Conflict: %s"; 
        msg = String.format(msg,
        docChange.getAddedRevision(), docChange.isConflict()); 
        Log.d(TAG, msg);
        documentChanged.countDown();
    } 
}); 
doc.createRevision().save();
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.CreateDocument();
doc.Change += (sender, e) =&gt;
{
    var change = e.Change;
    var documentId = change.DocumentId;
    var revisionId = change.RevisionId;
    var isConflict = change.IsConflict;
    var addedRev = change.AddedRevision;
};
</code></pre></span>
            <h2 id="Understanding Conflicts">Conflicts</h2><hr></hr>
                <p>So far we've been talking about a conflict as an error that occurs when you try to update a document that's been updated since you read it. In this scenario, Couchbase Lite is able to stop the conflict before it happens, giving your code a chance to re-read the document and incorporate the other changes.</p>
                <p>However, there's no practical way to prevent a conflict when the two updates are made on different instances of the database. Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other. A typical scenario is:</p>
                <ol><li>Molly creates DocumentA; the revision is 1-5ac</li><li>DocumentA is synced to Naomi's device; the latest revision is still
						1-5ac</li><li>Molly updates DocumentA, creating revision 2-54a</li><li>Naomi makes a different change to DocumentA, creating revision
                    2-877</li><li>Revision 2-877 is synced to Molly's device, which already has 2-54a,
						putting the document in conflict</li><li>Revision 2-54a is synced to Naomi's device, which already has 2-877,
                    similarly putting the local document in conflict</li></ol>
                <p>At this point, even though DocumentA is in a conflicted state, it needs
                to have a current revision. That is, when your app calls
                <code>getProperties</code>, Couchbase Lite has to return
                <em>something</em>. It chooses one of the two conflicting revisions
                (2-877 and 2-54a) as the "winner". The choice is deterministic, which means that
                every device that is faced with the same conflict will pick the same winner,
                without having to communicate. In this case it just compares the revision IDs
                "2-54a" and "2-877" and picks the higher one, "2-877".</p>
                <p>To be precise, Couchbase Lite uses the following rules to handle conflicts: </p>
                <ul><li>The winner is the undeleted leaf revision on the longest revision branch (i.e. with the largest prefix number in its revision ID.)</li><li>If there are no undeleted leaf revisions, the deletion (tombstone) on the longest branch wins.</li><li>If there's a tie, the winner is the one whose revision ID sorts higher in a simple ASCII comparison.</li></ul>
                
                <div class="note"><span class="tag">Note:</span>Couchbase Lite does not automatically merge the contents of conflicts.
                Automated merging sometimes works, but in many cases it'll give wrong results; only
                you know your document schemas well enough to decide how conflicts should be
                merged. </div>
                
                <p>In some cases this simple "one revision wins" rule is good enough. For
                example, in a grocery list if two people rename the same item, one of them will
                just see that their change got overwritten, and may do it over again. But usually
                the details of the document content are more important, so the application will
                want to detect and resolve conflicts.</p>
                <div class="note"><span class="tag">Note:</span>Resolving conflicts can also save the space in the database. Conflicting
                revisions stay in the database indefinitely until resolved, even surviving
                compactions. Therefore, it makes sense to deal with the conflict by at least
                deleting the non-winning revision. </div>
                <p> Another reason to resolve conflicts is to implement business rules. For
                example, if two sales associates update the same customer record and it ends up in
                conflict, you might want the sales manager to resolve the conflict and "hand merge"
                the two conflicting records so that no information is lost. </p>
                <p>There are two alternative ways to resolve a conflict:</p>
                <ul><li><strong>Pick a winner.</strong> Just decide which of the two changes
                    should win, and delete the other one. The deleted revision will no longer be
                    eligible as a conflict winner, so there won't be any more conflict.</li><li><strong>Merge.</strong> Consider the contents of both conflicting
                    revisions and construct a new revision that incorporates both. The details are,
                    of course, application-dependent, and might even require user interaction. Then
                    resolve the conflict by saving the merged revision, then deleting the old
                    losing conflict revision.</li></ul>
                <p>The following example shows how to resolve a conflict:</p>
                <div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>CBLDocument* doc = [database documentWithID: _myDocID];
NSError* error;
NSArray* conflicts = [doc getConflictingRevisions: &amp;error];
if (conflicts.count &gt; 1) {
    // There is more than one current revision, thus a conflict!
    [database inTransaction: ^BOOL{
        // Come up with a merged/resolved document in some way that's
        // appropriate for the app. You could even just pick the body of
        // one of the revisions.
        NSDictionary* mergedProps = [self mergeRevisions: conflicts];
    
        // Delete the conflicting revisions to get rid of the conflict:
        CBLSavedRevision* current = doc.currentRevision;
        for (CBLSavedRevision* rev in conflicts) {
            CBLUnsavedRevision *newRev = [rev createRevision];
            if (rev == current) {
                // add the merged revision
                newRev.properties = [NSMutableDictionary dictionaryWithDictionary: mergedProps]; 
            } else {
                // mark other conflicts as deleted
                newRev.isDeletion = YES;  
            }
            // saveAllowingConflict allows 'rev' to be updated even if it
            // is not the document's current revision.
            NSError *error;
            if (![newRev saveAllowingConflict: &amp;error])
                return NO;
        }
        return YES;
    }];
}
</code></pre></span><span class="stripe-display swift"><pre><code>let doc = database.documentWithID(myDocID)
var error: NSError?
if let conflicts = doc.getConflictingRevisions(&amp;error) as? [CBLSavedRevision]{
    if conflicts.count &gt; 1 {
        // There is more than one leaf revision, thus a conflict!
        database.inTransaction({ () -&gt; Bool in
            // Come up with a merged/resolved document in some way that's
            // appropriate for the app. You could even just pick the body of
            // one of the revisions.
            var mergedProps = self.mergeRevisions(conflicts)
            // Delete the conflicting revisions to get rid of the conflict:
            var current = doc.currentRevision
            for rev in conflicts {
                var newRev = rev.createRevision()
                if rev == current {
                    // add the merged revision
                    newRev.properties = NSMutableDictionary(dictionary: mergedProps)
                } else {
                    // mark other conflicts as deleted
                    newRev.isDeletion = true
                }
                // saveAllowingConflict allows 'rev' to be updated even if it
                // is not the document's current revision.
                var error: NSError?
                if newRev.saveAllowingConflict(&amp;error) == nil {
                    return false
                }
            }
            return true
        })
    }
}
</code></pre></span><span class="stripe-display java"><pre><code> 
                        final Document doc = database.getDocument(myDocID);
                        final List&lt;SavedRevision&gt; conflicts = doc.getConflictingRevisions();
                        if (conflicts.size() &gt; 1) {
                            // There is more than one current revision, thus a conflict!
                            database.runInTransaction(new TransactionalTask() {
                                @Override
                                public boolean run() {
                                    try {
                                        // Come up with a merged/resolved document in some way that's
                                        // appropriate for the app. You could even just pick the body of
                                        // one of the revisions.
                                        Map&lt;String, Object&gt; mergedProps = mergeRevisions(conflicts);
                                        // Delete the conflicting revisions to get rid of the conflict:
                                        SavedRevision current = doc.getCurrentRevision();
                                        for (SavedRevision rev : conflicts) {
                                            UnsavedRevision newRev = rev.createRevision();
                                            if (rev.getId().equals(current.getId())) {
                                                newRev.setProperties(mergedProps);
                                            } else {
                                                newRev.setIsDeletion(true);
                                            }
                                            // saveAllowingConflict allows 'rev' to be updated even if it
                                            // is not the document's current revision.
                                            newRev.save(true);
                                        }
                                    } catch (CouchbaseLiteException e) {
                                        return false;
                                    }
                                    return true;
                                }
                            });
                        }
                    
</code></pre></span><span class="stripe-display android"><pre><code> 
                        final Document doc = database.getDocument(myDocID);
                        final List&lt;SavedRevision&gt; conflicts = doc.getConflictingRevisions();
                        if (conflicts.size() &gt; 1) {
                            // There is more than one current revision, thus a conflict!
                            database.runInTransaction(new TransactionalTask() {
                                @Override
                                public boolean run() {
                                    try {
                                        // Come up with a merged/resolved document in some way that's
                                        // appropriate for the app. You could even just pick the body of
                                        // one of the revisions.
                                        Map&lt;String, Object&gt; mergedProps = mergeRevisions(conflicts);
                                        // Delete the conflicting revisions to get rid of the conflict:
                                        SavedRevision current = doc.getCurrentRevision();
                                        for (SavedRevision rev : conflicts) {
                                            UnsavedRevision newRev = rev.createRevision();
                                            if (rev.getId().equals(current.getId())) {
                                                newRev.setProperties(mergedProps);
                                            } else {
                                                newRev.setIsDeletion(true);
                                            }
                                            // saveAllowingConflict allows 'rev' to be updated even if it
                                            // is not the document's current revision.
                                            newRev.save(true);
                                        }
                                    } catch (CouchbaseLiteException e) {
                                        return false;
                                    }
                                    return true;
                                }
                            });
                        }
                    
</code></pre></span><span class="stripe-display c"><pre><code>var doc = database.GetDocument(myDocId);
var conflicts = doc.ConflictingRevisions.ToList();
if (conflicts.Count &gt; 1)
{
    // There is more than one current revision, thus a conflict!
    database.RunInTransaction(() =&gt; 
    {
        var mergedProps = MergeRevisions(conflicts);
        var current = doc.CurrentRevision;
        foreach(var rev in conflicts)
        {
            var newRev = rev.CreateRevision();
            if (rev == current)
            {
                newRev.SetProperties(mergedProps);
            }
            else
            {
                newRev.IsDeletion = true;
            }
            // saveAllowingConflict allows 'rev' to be updated even if it
            // is not the document's current revision.
            newRev.SaveAllowingConflict();
        }
        return true;
    });
}
</code></pre></span>
                <h3 id="conflict-faq">Document Conflict FAQ</h3><dl><dt><em>What if both devices make the same change to the document? Is that a conflict?</em></dt><dd>No. The revision ID is derived from a digest of the document body. So if two databases save identical changes, they end up with identical revision IDs, and Couchbase Lite (and the Sync Gateway) treat these as the same revision.</dd><dt><em>I deleted a document, but the it's still in the database, only now its properties are different. What happened?</em></dt><dd>Sounds like the document was in conflict and you didn't realize it. You deleted the winning revision, but that made the other (losing) revision become the current one. If you delete the document again, it'll actually go away.</dd><dt><em>How can I get the properties of the common ancestor revision, to do a three-way merge?</em></dt><dd>You can't always. Couchbase Lite isn't a version-control system and doesn't preserve old revision bodies indefinitely. But if the ancestor revision used to exist in your local database, and you haven't yet compacted the database, you can still get its properties. Get the <code>parentRevision</code> property of the current revision to get the ancestor, then see if its <code>properties</code> are still non-null.</dd><dt><em>How can I tell if a document has a conflict?</em></dt><dd>Call its <code>getConflictingRevisions</code> method and see if more than one revision is returned.</dd><dt><em>How can I tell if there are any conflicts in the database?</em></dt><dd>Use an <a href="../../../../../develop/guides/couchbase-lite/native-api/query/index.html#all-docs">all-documents query</a> with the <code>onlyConflicts</code> mode.</dd></dl>
            <h2 id="purging-a-document">Purging documents</h2><hr></hr>
                <p>Purging a document is different from deleting it; it's more like <em>forgetting</em> it. The <code>purge</code> method removes all trace of a document (and all its revisions and their attachments) from the <em>local</em> database. It has no effect on replication or on remote databases, though.</p>
                <p>Purging is mostly a way to save disk space by forgetting about replicated documents that you don't need anymore. It has some slightly weird interactions with replication, though. For example, if you purge a document, and then later the document is updated on the remote server, the next replication will pull the document into your database again.</p>
            <h2 id="special-properies">Special Properties</h2><hr></hr>
                <p>The body of a document contains a few special properties that store metadata about the document. For the most part you can ignore these since the API provides accessor methods for the same information, but it can still be helpful to know what they are if you encounter them.</p>
                <ul><li><code>_id</code>: The document ID.</li><li><code>_rev</code>: The revision ID.</li><li><code>_attachments</code>: Metadata about the document's attachments.</li><li><code>_deleted</code>: Only appears in a deletion (tombstone) revision, where it has the value <code>true</code>.</li></ul>
                <div class="note"><span class="tag">Note:</span>A leading underscore always denotes a reserved property—don’t
					use an underscore prefix for any of your own properties, and don't change the value of any reserved property. </div>
            </article></div><div class="page-footer"><span>Copyright © 2015 Couchbase Inc.  All rights reserved.</span><a href="http://www.couchbase.com/terms-of-service">Terms of Use</a><a href="http://www.couchbase.com/privacy">Privacy Policy</a></div></body></html>