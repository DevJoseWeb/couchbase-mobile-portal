<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>Replication | Couchbase - Mobile Developers</title><link rel="stylesheet" type="text/css" href="../../../../../styles/style.css"></link><style class="language-stripe" id="language-stripe-objective-c" type="text/css">*.stripe-display.objective-c{display:inline;}*.stripe-active.objective-c{background:rgba(0, 0, 0, 0.05);}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-swift" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:inline;}*.stripe-active.swift{background:rgba(0, 0, 0, 0.05);}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-java" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:inline;}*.stripe-active.java{background:rgba(0, 0, 0, 0.05);}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-android" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:inline;}*.stripe-active.android{background:rgba(0, 0, 0, 0.05);}*.stripe-display.c{display:none;}*.stripe-active.c{background:transparent;}</style><style class="language-stripe" id="language-stripe-c" type="text/css">*.stripe-display.objective-c{display:none;}*.stripe-active.objective-c{background:transparent;}*.stripe-display.swift{display:none;}*.stripe-active.swift{background:transparent;}*.stripe-display.java{display:none;}*.stripe-active.java{background:transparent;}*.stripe-display.android{display:none;}*.stripe-active.android{background:transparent;}*.stripe-display.c{display:inline;}*.stripe-active.c{background:rgba(0, 0, 0, 0.05);}</style><script type="text/javascript">var languages = ["objective-c","swift","java","android","c"];
                    
	                var cookies = document.cookie.split(';');
				    for(var i=0; i<cookies.length; i++) {
				        var cookie = cookies[i].trim();
				        
				        if (cookie.indexOf("language=")==0) {
				            var selectedLanguage = cookie.substring(9, cookie.length);
				            if (selectedLanguage.length > 0) {
				                document.write("<style class='language-stripe' type='text/css'>");
				                for (var j=0; j<languages.length; j++) {
				                    var language = languages[j];
				                    document.write("*.stripe-display." + language + "{display:" + (language == selectedLanguage ? "inline" : "none") + ";}");
                                    document.write("*.stripe-active." + language + "{background:" + (language == selectedLanguage ? "rgba(0, 0, 0, 0.05)" : "transparent") + ";}");
				                }
				                document.write("</style>");
				            }
				            break;
				        }
				    }
				    
			    </script><script type="text/javascript">
                var rootPath = "../../../../../";</script><script src="../../../../../scripts/core.js"></script><script src="../../../../../scripts/search-core.js"></script><script src="../../../../../scripts/search.js"></script><script src="../../../../../scripts/search-index.js"></script><script type="text/javascript">
	        
	        var _gaq = _gaq || [];
	        _gaq.push(['_setAccount', 'UA-7763794-1']);
	        _gaq.push(['_trackPageview']);

	        (function() {
	            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	        })();
	        
	    </script></head><body onload="init()"><div class="page-header"><table class="navigator-bar"><tr><td><a class="dark logo" href="../../../../../index.html"><div>Couchbase</div><div>Mobile Developers</div></a></td><td><a class="dark" href="../../../../../get-started/get-started-mobile/index.html">Get Started</a></td><td><a class="dark active" href="../../../../../develop/training/build-first-ios-app/index.html">Develop</a></td><td><a class="dark" href="https://forums.couchbase.com/mobile">Forums</a></td><td width="100%"></td><td><input class="search" type="text" onkeyup="search_onkeyup(this)" onchange="search_onchange(this)" onfocus="search_onfocus(this)" onblur="search_onblur(this)"></input></td></tr></table><div class="search-results-wrapper"><div class="search-results-floater"><div id="search-results" class="hidden"></div></div></div><table class="navigator-bar secondary"><tr><td><a class="dark" href="../../../../../develop/training/build-first-ios-app/index.html">Training</a></td><td><a class="dark active" href="../../../../../develop/guides/modeling/index.html">Guides</a></td><td><a class="dark" href="../../../../../develop/references/couchbase-lite/index.html">API References</a></td><td><a class="dark" href="../../../../../develop/samples/samples/index.html">Samples</a></td><td><a class="dark" href="http://www.couchbase.com/nosql-databases/downloads#Couchbase_Mobile">Downloads</a></td><td width="100%"></td></tr></table></div><div class="header-spacer"></div><div class="page-wrapper"><nav><ul class="nav-list"><li class="nav-section"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/modeling/index.html">Data Modeling</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/modeling/basics/index.html">The Basics</a></li><li class="nav-item"><a href="../../../../../develop/guides/modeling/one-to-many/index.html">One-to-Many Relationships</a></li></ul></li><li class="nav-section expanded"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/couchbase-lite/index.html">Couchbase Lite</a></div><ul><li class="nav-subsection expanded"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/couchbase-lite/native-api/index.html">Native API</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/manager/index.html">Manager</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/database/index.html">Database</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/document/index.html">Document</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/revision/index.html">Revision</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/attachment/index.html">Attachment</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/view/index.html">View</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/query/index.html">Query</a></li><li class="nav-item active"><a href="../../../../../develop/guides/couchbase-lite/native-api/replication/index.html">Replication</a></li><li class="nav-item"><a href="../../../../../develop/guides/couchbase-lite/native-api/model/index.html">Model (iOS only)</a></li></ul></li></ul></li><li class="nav-section"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/index.html">Sync Gateway</a></div><ul><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/index.html">Running the Sync Gateway</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/installing-sync-gateway/index.html">Installing Sync Gateway</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/connecting-sync-gateway-to-couchbase-server/index.html">Connecting Sync Gateway to Couchbase Server</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/starting-sync-gateway/index.html">Starting Sync Gateway</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/getting-started-with-sync-gateway/stopping-sync-gateway/index.html">Stopping Sync Gateway</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/index.html">Configuration and administration</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/command-line-tool/index.html">Configuration options</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/administering-the-rest-apis/index.html">Administering the REST APIs</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/authorizing-users/index.html">Authorizing Users</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/administering-sync-gateway/authenticating-users/index.html">Authenticating Users</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/channels/index.html">Data routing with "channels"</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/intro/index.html">Introduction to channels</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/developing/index.html">Developing channels</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/channels/troubleshooting/index.html">Troubleshooting channels</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/index.html">Sync Function API</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/intro/index.html">Introduction</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/validation/index.html">Validation and Authorization</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/routing/index.html">Routing</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/changes-worker/index.html">Connecting additional backend processes</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/pattern/index.html">Changes Worker Pattern</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/example-workflow/index.html">Example Document Workflow</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/changes-worker/push/index.html">Push Notification Code</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/deployment/index.html">Deployment considerations</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/during-development/index.html">During Development</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/in-production/index.html">In Production</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/deployment/troubleshooting/index.html">Troubleshooting and Fine-Tuning</a></li></ul></li><li class="nav-subsection"><div onclick="toggleExpanded(this.parentNode)" class="header"><a href="../../../../../develop/guides/sync-gateway/nginx/index.html">Deploying Sync Gateway behind a reverse proxy</a></div><ul><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/nginx/introduction-to-reverse-proxies/index.html">Introduction to reverse proxies</a></li><li class="nav-item"><a href="../../../../../develop/guides/sync-gateway/nginx/configuring-nginx-for-sync-gateway/index.html">Deploying and configuring nginx</a></li></ul></li></ul></li></ul></nav><article class="content-wrapper"><h1>Replication</h1><div class="toc"><h2>In this document</h2><ul class="plain"><li><a href="#types">Types of replications</a></li><li><a href="#creating">Creating and configuring replications</a></li><li><a href="#authentication">Authenticating replications</a><ul><li><a href="#basic-auth">HTTP Basic authentication</a></li><li><a href="#facebook-auth">Facebook authentication</a></li><li><a href="#persona-auth">Persona authentication</a></li><li><a href="#custom-auth">Custom authentication</a></li></ul></li><li><a href="#filters">Filtered replications</a><ul><li><a href="#filtered_push">Filtered push replications</a></li><li><a href="#filtered_pull">Filtered pull from Sync Gateway</a></li><li><a href="#filtered_pull_p2p">Filtered pull from Couchbase Lite (peer-to-peer)</a></li><li><a href="#filtered_pull_couchdb">Filtered pull from CouchDB, PouchDB or Cloudant</a></li></ul></li><li><a href="#observing">Observing and monitoring replications</a></li></ul></div><p>
            A Replication object represents a replication (or "sync") task that transfers changes between a local database and a remote one. To replicate, you first get a new Replication object from a Database, then configure its settings, then tell it to start. The actual replication runs asynchronously on a background thread; you can monitor its progress by observing notifications posted by the Replication object when its state changes, as well as notifications posted by the database when documents are changed by the replicator.
        </p><p>
            A typical application will create a pair of replications (push and pull) at launch time, both pointing to the URL of a server run by the application vendor. These stay active continuously during the lifespan of the app, uploading and downloading documents as changes occur and when the network is available.
        </p><p>(Of course, <em>atypical</em> applications can use replication differently. The architecture is very flexible, supporting one-way replication, peer-to-peer replication, and replication between multiple devices and servers in arbitrary directed graphs. An app might also choose to replicate only once in a while, or only with a subset of its documents.)</p><p>The application code doesn't have to pay attention to the details: it just knows that when it makes changes to the local database they will eventually be uploaded to the server, and when changes occur on the server they will eventually be downloaded to the local database. The app's job is to make the UI reflect what's in the local database, and to reflect user actions by making changes to local documents. If it does that, replication will Just Work without much extra effort.</p><h2 id="types">Types of replications</h2><hr></hr>
                <ul><li><strong>Push vs Pull:</strong> A push replication uploads changes from the local database to the remote one; a pull downloads changes from the remote database to the local one.</li><li><strong>One-shot vs Continuous:</strong> By default a replication runs long enough to transfer all the changes from the source to the target database, then quits. A continuous replication, on the other hand, will stay active indefinitely, watching for further changes to occur and transferring them.</li><li><strong>Filtered:</strong> Replications can have filters that restrict what documents they'll transfer. This can be useful to limit the amount of a large remote database that's downloaded to a device, or to keep some local documents private. A special type of filter used with the Couchbase Sync Gateway is the set of <strong>channels</strong> that a pull replication will download from. It's also possible to limit a replication to an explicit set of document IDs.</li></ul>
            <h2 id="creating">Creating and configuring replications</h2><hr></hr>
                <p>
                    You create a Replication object by calling the Database methods <code>createPullReplication</code> or <code>createPushReplication</code>. Both of these take a single parameter, the URL of the remote database to sync with. As the names imply, each method creates a replication that transfers changes in one direction only; if you want bidirectional sync, as most apps do, you should create one of each.
                </p>
                <p>
                    Next you can customize the replication settings. The most common change is to set the <code>continuous</code> property to <code>true</code>. You may also need to supply authentication credentials, like a username/password or a Facebook token.
                </p>
                <div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>NSURL* url = [NSURL URLWithString: @"https://example.com/mydatabase/"];
CBLReplication *push = [database createPushReplication: url];
CBLReplication *pull = [database createPullReplication: url];
push.continuous = pull.continuous = YES;
id&lt;CBLAuthenticator&gt; auth;
auth = [CBLAuthenticator basicAuthenticatorWithName: username
                                           password: password];
push.authenticator = pull.authenticator = auth;
</code></pre></span><span class="stripe-display swift"><pre><code>let url = NSURL(string: "https://example.com/mydatabase/")
let push = database.createPushReplication(url)
let pull = database.createPullReplication(url)
push.continuous = true
pull.continuous = true
var auth: CBLAuthenticatorProtocol?
auth = CBLAuthenticator.basicAuthenticatorWithName(username, password: password)
push.authenticator = auth
pull.authenticator = auth
</code></pre></span><span class="stripe-display java"><pre><code>URL url = new URL("https://example.com/mydatabase/");
Replication push = database.createPushReplication(url);
Replication pull = database.createPullReplication(url);
pull.setContinuous(true);
push.setContinuous(true);
Authenticator auth = new BasicAuthenticator(username, password);
push.setAuthenticator(auth);
pull.setAuthenticator(auth);
</code></pre></span><span class="stripe-display android"><pre><code>URL url = new URL("https://example.com/mydatabase/");
Replication push = database.createPushReplication(url);
Replication pull = database.createPullReplication(url);
pull.setContinuous(true);
push.setContinuous(true);
Authenticator auth = new BasicAuthenticator(username, password);
push.setAuthenticator(auth);
pull.setAuthenticator(auth);
</code></pre></span><span class="stripe-display c"><pre><code>var url = new Uri("https://example.com/mydatabase/");
var push = database.CreatePushReplication(url);
var pull = database.CreatePullReplication(url);
var auth = AuthenticatorFactory.CreateBasicAuthenticator(username, password);
push.Authenticator = auth;
pull.Authenticator = auth;
push.Continuous = true;
pull.Continuous = true;
</code></pre></span>
                <p>
                    You will also probably want to monitor the replication's progress, particularly because this will tell you if errors occur, but also if you want to display a progress indicator to the user. The API for registering as an observer is platform-specific.
                </p>
                <p>
                    Once everything is set, you call <code>start</code> to start the replication. If the replication is continuous, it'll keep running indefinitely. Otherwise, the replication will eventually stop when it's transferred everything.
                </p>
                <div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>[[NSNotificationCenter defaultCenter] addObserver: self
                                         selector: @selector(replicationChanged:)
                                             name: kCBLReplicationChangeNotification
                                           object: push];
[[NSNotificationCenter defaultCenter] addObserver: self
                                         selector: @selector(replicationChanged:)
                                             name: kCBLReplicationChangeNotification
                                           object: pull];
[push start];
[pull start];
// It's important to keep a reference to a running replication,
// or it is likely to be dealloced!
self.push = push;
self.pull = pull;
// The replications are running now; the -replicationChanged: method will
// be called with notifications when their status changes.
</code></pre></span><span class="stripe-display swift"><pre><code>NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged", name: kCBLReplicationChangeNotification, object: push)
NSNotificationCenter.defaultCenter().addObserver(self,
    selector: "replicationChanged", name: kCBLReplicationChangeNotification, object: pull)
push.start()
pull.start()
// It's important to keep a reference to a running replication,
// or it is likely to be dealloced!
self.push = push;
self.pull = pull;
// The replications are running now; the -replicationChanged: method will
// be called with notifications when their status changes.
</code></pre></span><span class="stripe-display java"><pre><code>push.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the push replication status changes
    }
});
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the pull replication status changes
    }
});
push.start();
pull.start();
this.push = push;
this.pull = pull;
</code></pre></span><span class="stripe-display android"><pre><code>push.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the push replication status changes
    }
});
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // will be called back when the pull replication status changes
    }
});
push.start();
pull.start();
this.push = push;
this.pull = pull;
</code></pre></span><span class="stripe-display c"><pre><code>push.Changed += (sender, e) =&gt; 
{
    // Will be called when the push replication status changes
};
pull.Changed += (sender, e) =&gt; 
{
    // Will be called when the pull replication status changes
};
push.Start();
pull.Start();
this.push = push;
this.pull = pull;
</code></pre></span>
            <h2 id="authentication">Authenticating replications</h2><hr></hr>
                <p>Most of the time the remote server will not allow guest access (especially for uploads), so the replicator will need to authenticate itself to it. The replication protocol runs over HTTP — it's an extension of the Sync Gateway and CouchDB REST API — so the authentication mechanisms are pretty standard ones. You generally configure authentication by creating an Authenticator object and assigning it to the replication's <code>authenticator</code> property.</p>
                <h3 id="basic-auth">HTTP Basic authentication</h3><p>The simplest type of authentication is HTTP Basic Auth. This simply adds the username and password to a header in each request. It is, obviously, completely insecure unless used over an SSL connection.</p><p>The main way to use basic auth is to create an Authenticator, but it's also possible (though less desirable) to embed the username and password in the replication URL; the syntax looks like <code>https://username:password@example.com/database</code></p><p>On iOS and Mac OS you can also take advantage of the URL loading system's credential store and Keychain. Credentials registered this way will automatically be applied to requests made by the replicator. You can easily do this by creating an <code>NSURLCredential</code> object and assigning it to the replication's <code>credential</code> property. Or if you use the Keychain APIs to persistently store a credential in the application's keychain, it will always be available to the replicator. This is the most secure way to store a credential, since the keychain file is encrypted.</p>
                <h3 id="facebook-auth">Facebook authentication</h3><p>The Couchbase Sync Gateway allows clients to authenticate using a Facebook account. Your application is responsible for generating a Facebook token; this generally needs to be done by running the Facebook login flow inside a web-view and capturing the generated token. Facebook provides SDKs for both iOS and Android to assist in doing this, and on iOS the Accounts framework can be used to retrieve an active login token (with the user's consent.)</p><p>You'll also need to ensure you've asked for the <code>email</code> permission in your Facebook app configuration.</p><p>Once you have the token, you just need to call a factory method to create an Authenticator from it, and assign that to the replication's <code>authenticator</code> property.</p><p>The server will send the token to Facebook's servers to validate it, and if successful will generate a login session and return a session cookie to the app. The session will eventually expire, so you should be prepared to detect an authentication failure (HTTP 401 status) reported by the replication, and get a new token from Facebook.</p>
                <h3 id="persona-auth">Persona authentication</h3><p><a href="http://persona.org">Persona</a> is a universal login system developed by the Mozilla Foundation. It uses any email address as the user identity, so one isn't required to have an account at any particular social-networking site. Otherwise, from the app perspective, it works similarly to Facebook auth: the app needs to get a token (called an "assertion") that's generated by the user's logging in on a website, and send that assertion to the remote database server.</p><p>Unfortunately Mozilla's mobile SDKs for Persona aren't up-to-date. Couchbase has <a href="https://github.com/couchbaselabs/persona-ios">a working one for iOS apps</a>.</p><p>Once you have the token, you just need to call a factory method to create an Authenticator from it, and assign that to the replication's <code>authenticator</code> property.</p><p>The server will send the token to persona.org to validate it, and if successful will generate a login session and return a session cookie to the app. The session will eventually expire, so you should be prepared to detect an authentication failure (HTTP 401 status) reported by the replication, and generate a new assertion.</p>
                <h3 id="custom-auth">Custom authentication</h3><p>It's possible for an application server associated with a remote Couchbase Sync Gateway to provide its own custom form of authentication. Generally this will involve a particular URL that the app needs to post some form of credentials to; the app server will verify those, then tell the Sync Gateway to create a new login session for the user, and return a session cookie in its response to the client app.</p><p>Since the app server's URL probably does not share the same hostname and port as the remote database, the returned cookie won't automatically be applied to the HTTP requests sent by the replicator (because it belongs to a different "security zone".) In that case you'll need to get the <code>Set-Cookie</code> header from the app server's response and register that cookie with the replication by calling its <code>setCookie</code> method.</p>
            <h2 id="filters">Filtered replications</h2><hr></hr>
                <p>
                    You can restrict a replication to only a subset of the available documents, by writing a filter function. There are several types of filtered replication, based on the direction and the type of server.
                </p>
                <h3 id="filtered_push">Filtered push replications</h3><p>During a push replication, the candidate documents live in your local database, so the filter function runs locally. You define it as a native function (a block in Objective-C, an inner class method in Java), assign it a name, and register it with the Database object. You then set the filter's name as the <code>filter</code> property of the Replication object.</p><p>The replicator passes your filter function a <code>SavedRevision</code> object. The function can examine the document's ID and properties, and simply returns <code>true</code> to allow the document to be replicated, or <code>false</code> to prevent it from being replicated.</p><div class="note caution"><span class="tag">Caution:</span>The filter function will be called on the replicator's background thread, so it should be thread-safe. Ideally it shouldn't reference any external state, but this isn't strictly required.</div><p>The filter function can also be given parameters. The parameter values are specified in the <code>Replication.filterParams</code> property as a dictionary/map, and passed to the filter function. This way you can write a generalized filter that can be used with different replications, and also avoid referencing external state from within the function. For example, a function could filter documents created in any year, accepting the specific year as a parameter.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java disabled">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android disabled">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>// Define a filter that matches only docs with a given "owner" property.
// The value to match is given as a parameter named "name":
[db setFilterNamed: @"byOwner" asBlock: FILTERBLOCK({
    NSString* nameParam = params[@"name"];
    return nameParam &amp;&amp; [revision[@"owner"] isEqualToString: nameParam];
})];
//
// Set up a filtered push replication using the above filter block,
// that will push only docs whose "owner" property equals "Waldo":
CBLReplication *push = [database createPushReplication: url];
push.filter = @"byOwner";
push.filterParams = @{@"name": @"Waldo"};
</code></pre></span><span class="stripe-display swift"><pre><code>db.setFilterNamed("byOwnder", asBlock: { 
    (revision, params) -&gt; Bool in
        let nameParam = params["name"] as? String
        return nameParam != nil &amp;&amp; nameParam! == revision["owner"] as? String
})
</code></pre></span><span class="stripe-display java"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display android"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display c"><pre><code>// Define a filter that matches only docs with a given "owner" property.
// The value to match is given as a parameter named "name":
database.SetFilter("byOwner", (revision, filterParams) =&gt;
{
    var nameParam = filterParams["name"];
    var owner = (string)revision.GetProperty("owner");
    return (nameParam != null) &amp;&amp; nameParam.Equals(owner);
});
// Set up a filtered push replication using the above filter block,
// that will push only docs whose "owner" property equals "Waldo":
var push = database.CreatePushReplication(url);
push.Filter = "byOwner";
push.FilterParams = new Dictionary&lt;string, object&gt; { {"name", "Waldo"} };
</code></pre></span>
                
                <h3 id="filtered_pull">Filtered pull from Sync Gateway</h3><p><a href="../../../../../develop/guides/sync-gateway/channels/intro/index.html#intro">Channels</a> are used to filter documents being pulled from the Sync Gateway. Every document stored in a Sync Gateway database is tagged with a set of named channels by the Gateway's app-defined <a href="../../../../../develop/guides/sync-gateway/sync-function-api-guide/index.html#sync-function-api-guide">sync function</a>. Every pull replication from the Gateway is already implicitly filtered by the set of channels that the user's account is allowed to access; you can filter it further by creating an array of channel names and setting it as the value of the <code>channels</code> property of a pull Replication. Only documents tagged with those channels will be downloaded.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java disabled">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android disabled">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>// Set up a channel-filtered pull replication that will pull only
// docs in the "sales" channel from the Sync Gateway:
CBLReplication *pull = [database createPullReplication: url];
pull.channels = @[@"sales"];
</code></pre></span><span class="stripe-display swift"><pre><code>// Set up a channel-filtered pull replication that will pull only
// docs in the "sales" channel from the Sync Gateway:
database.createPullReplication(url)
pull.channels = ["sales"]
</code></pre></span><span class="stripe-display java"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display android"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display c"><pre><code>// Set up a channel-filtered pull replication that will pull only
// docs in the "sales" channel from the Sync Gateway:
var pull = database.CreatePullReplication(url);
pull.Channels = new List&lt;string&gt; { "sales" };
</code></pre></span>
                <h3 id="filtered_pull_p2p">Filtered pull from Couchbase Lite (peer-to-peer)</h3><p>Couchbase Lite can replicate with another instance of itself, if the other instance includes the optional Listener component and is listening on a TCP port. If the other instance has registered a filter block/method, as described above under "Filtered push replications", then you can use this filter when pulling from it. Just set your pull replication's <code>filter</code> property to the same name that the remote filter function is registered with.</p><div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java disabled">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android disabled">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c disabled">C#</a></div><span class="stripe-display objective-c"><pre><code>// Set up a filtered pull replication from another CBL instance, that
// will use a filter block registered on the other instance (as shown
// in a previous example) to pull only docs whose "owner" property is
// equal to "Waldo":
CBLReplication *pull = [database createPullReplication: peerUrl];
pull.filter = @"byOwner";
pull.filterParams = @{@"name": @"Waldo"};
</code></pre></span><span class="stripe-display swift"><pre><code>// Set up a filtered pull replication from another CBL instance, that
// will use a filter block registered on the other instance (as shown
// in a previous example) to pull only docs whose "owner" property is
// equal to "Waldo":
let pull = database.createPullReplication(url)
pull.filter = "byOwner"
pull.filterParams = ["name" : "Waldo"]
</code></pre></span><span class="stripe-display java"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display android"><pre><code class="disabled">No code example is currently available.</code></pre></span><span class="stripe-display c"><pre><code class="disabled">No code example is currently available.</code></pre></span>
                <h3 id="filtered_pull_couchdb">Filtered pull from CouchDB, PouchDB or Cloudant</h3><p>Other non-Couchbase databases that Couchbase Lite can replicate with don't support channels, but they do support server-side filter functions. These are implemented in JavaScript and stored in special "design documents" in the server-side database. The <a href="http://docs.couchdb.org/en/latest/couchapp/ddocs.html#filter-functions">CouchDB documentation</a> describes how to write and install them.</p><p>To use such a filter function in a pull replication, set the Replication object's <code>filter</code> property to a string of the form <em>designDocName</em>/<em>filterName</em>. For example, if the server-side design document is named <code>_design/access</code> and you want to use its filter function called <code>byYear</code>, you would set the <code>Replication.filter</code> property to <code>"access/byYear".</code></p><p>(The same example from the previous section applies here too; the difference is on the remote server, where the <code>byOwner</code> filter would be defined as a JavaScript function stored in a design document.)</p>
            <h2 id="observing">Observing and monitoring replications</h2><hr></hr>
                <p>
                    Since a replication runs asynchronously, if you want to know when it completes or when it gets an error, you'll need to register as an observer to get notifications from it. The details of this are platform-specific.
                </p>
                <p>A replication has a number of properties that you can access, especially from a notification callback, to check on its status and progress:</p>
                <ul><li>
                        <code>status</code>: An enumeration that gives the current state of the replication. The values are Stopped, Offline, Idle and Active.
                        <ul><li>Stopped: A one-shot replication goes into this state after all documents have been transferred or a fatal error occurs. (Continuous replications never stop.)</li><li>Offline: The remote server is not reachable. Most often this happens because there's no network connection, but it can also occur if the server's inside an intranet or home network but the device isn't. (The replication will monitor the network state and will try to connect when the server becomes reachable.)</li><li>Idle: Indicates that a continuous replication has "caught up" and transferred all documents, but is monitoring the source database for future changes.</li><li>Active: The replication is actively working, either transferring documents or determining what needs to be transferred.</li></ul>
                    </li><li><code>lastError</code>: The last error encountered by the replicator. (Not all errors are fatal, and a continuous replication will keep running even after a fatal error, by waiting and retrying later.)</li><li><code>completedChangesCount</code>, <code>changesCount</code>: The number of documents that have been transferred so far, and the estimated total number to transfer in order to catch up. The ratio of these can be used to display a progress meter. Just be aware that <code>changesCount</code> may be zero if the number of documents to transfer isn't known yet, and in a continuous replication both values will reset to zero when the status goes from Idle back to Active.</li></ul>
                <div class="tab-bar"><a href="javascript:setLanguage(&#34;objective-c&#34;)" class="tab stripe-active objective-c">Objective-C</a><a href="javascript:setLanguage(&#34;swift&#34;)" class="tab stripe-active swift">Swift</a><a href="javascript:setLanguage(&#34;java&#34;)" class="tab stripe-active java">Java</a><a href="javascript:setLanguage(&#34;android&#34;)" class="tab stripe-active android">Android</a><a href="javascript:setLanguage(&#34;c&#34;)" class="tab stripe-active c">C#</a></div><span class="stripe-display objective-c"><pre><code>- (void) replicationChanged: (NSNotification*)n {
    // The replication reporting the notification is n.object , but we
    // want to look at the aggregate of both the push and pull.
    
    // First check whether replication is currently active:
    BOOL active = (pull.status == kCBLReplicationActive) || (push.status == kCBLReplicationActive);
    self.activityIndicator.state = active;
    // Now show a progress indicator:
    self.progressBar.hidden = !active;
    if (active) {
        double progress = 0.0;
        double total = push.changesCount + pull.changesCount;
        if (total &gt; 0.0) {
            progress = (push.completedChangesCount + pull.completedChangesCount) / total;
        }
        self.progressBar.progress = progress;
    }
}
</code></pre></span><span class="stripe-display swift"><pre><code>- (void) replicationChanged: (NSNotification*)n {
    // The replication reporting the notification is n.object , but we
    // want to look at the aggregate of both the push and pull.
    
    // First check whether replication is currently active:
    let active = pull.status == CBLReplicationStatus.Active || push.status == CBLReplicationStatus.Active
    self.activityIndicator.state = active
    // Now show a progress indicator:
    self.progressBar.hidden = !active;
    if active {
        var progress = 0.0
        let total = push.changesCount + pull.changesCount
        let completed = push.completedChangesCount + pull.completedChangesCount
        if total &gt; 0 {
            progress = Double(completed) / Double(total);
        }
        self.progressBar.progress = progress;
    }
}
</code></pre></span><span class="stripe-display java"><pre><code>final ProgressDialog progressDialog = ProgressDialog.show(MainActivity.this, "Please wait ...", "Syncing", false);
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // The replication reporting the notification is either
        // the push or the pull, but we want to look at the
        // aggregate of both the push and pull.
        // First check whether replication is currently active:
        boolean active = (pull.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE) ||
        (push.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE);
        if (!active) {
            progressDialog.dismiss();
        } else {
            double total = push.getCompletedChangesCount() + pull.getCompletedChangesCount();
            progressDialog.setMax(total);
            progressDialog.setProgress(push.getChangesCount() + pull.getChangesCount());
        }
    }
});
</code></pre></span><span class="stripe-display android"><pre><code>final ProgressDialog progressDialog = ProgressDialog.show(MainActivity.this, "Please wait ...", "Syncing", false);
pull.addChangeListener(new Replication.ChangeListener() {
    @Override
    public void changed(Replication.ChangeEvent event) {
        // The replication reporting the notification is either
        // the push or the pull, but we want to look at the
        // aggregate of both the push and pull.
        // First check whether replication is currently active:
        boolean active = (pull.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE) ||
        (push.getStatus() == Replication.ReplicationStatus.REPLICATION_ACTIVE);
        if (!active) {
            progressDialog.dismiss();
        } else {
            double total = push.getCompletedChangesCount() + pull.getCompletedChangesCount();
            progressDialog.setMax(total);
            progressDialog.setProgress(push.getChangesCount() + pull.getChangesCount());
        }
    }
});
</code></pre></span><span class="stripe-display c"><pre><code>// The replication reporting the notification is either
// the push or the pull, but we want to look at the
// aggregate of both the push and pull.
// First check whether replication is currently active:
var active = push.Status == ReplicationStatus.Active ||
             pull.Status == ReplicationStatus.Active;
if (!active)
{
    DismissProgressBar();
}
else
{
    var total = push.CompletedChangesCount + pull.CompletedChangesCount;
    var progress = push.ChangesCount + pull.ChangesCount;
    ShowProgressBar(progress, total);
}
</code></pre></span>
            </article><div class="page-footer"><span>Copyright © 2014 Couchbase Inc.  All rights reserved.</span><a href="http://www.couchbase.com/terms-of-service">Terms of Use</a><a href="http://www.couchbase.com/privacy">Privacy Policy</a></div></div></body></html>